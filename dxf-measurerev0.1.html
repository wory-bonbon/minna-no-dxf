<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DXF 計測ツール（スタンドアロン版）</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* カスタムスタイル */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* 全体のスクロールを無効化 */
        }
        #root {
            height: 100vh;
            overflow: hidden;
        }
        .sidebar-scroll::-webkit-scrollbar { width: 6px; }
        .sidebar-scroll::-webkit-scrollbar-track { background: #1e293b; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React & Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // 型定義は削除（JavaScriptとして実行）
        
        // ユーティリティ関数
        function useFileText() {
            const [text, setText] = useState(null);
            const pickFile = (f) => {
                const tryDecode = async () => {
                    const buf = await f.arrayBuffer();
                    const d = new Uint8Array(buf);
                    const encoders = ["shift_jis", "ms932", "utf-8"];
                    for (const enc of encoders) {
                        try {
                            const td = new TextDecoder(enc, { fatal: false });
                            const s = td.decode(d);
                            if (s.includes("SECTION") && s.includes("ENTITIES")) {
                                setText(s);
                                return;
                            }
                        } catch (_) {}
                    }
                    setText(new TextDecoder().decode(d));
                };
                tryDecode();
            };
            return { text, pickFile };
        }

        // 2D 基本処理
        function rad(deg) { return (deg * Math.PI) / 180; }
        function rotateAround(p, pivot, deg) {
            if (deg % 360 === 0) return { ...p };
            const th = rad(deg);
            const s = Math.sin(th), c = Math.cos(th);
            const x = p.x - pivot.x, y = p.y - pivot.y;
            return { x: pivot.x + x * c - y * s, y: pivot.y + x * s + y * c };
        }
        function rotateVec(v, deg) {
            if (deg % 360 === 0) return { ...v };
            const th = rad(deg); 
            const c = Math.cos(th), s = Math.sin(th);
            return { x: v.x * c - v.y * s, y: v.x * s + v.y * c };
        }
        function transformPoint(p, base, insert, sx, sy, angDeg) {
            const dx = (p.x - base.x) * sx;
            const dy = (p.y - base.y) * sy;
            const th = rad(angDeg);
            const cx = Math.cos(th), sn = Math.sin(th);
            return { x: insert.x + (dx * cx - dy * sn), y: insert.y + (dx * sn + dy * cx) };
        }

        // フィット計算
        function computeFitFromPoints(points, pivot, deg, canvasW, canvasH) {
            if (!points.length) return { s: 1, tx: 0, ty: 0, bounds: null };
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const p of points) {
                const r = rotateAround(p, pivot, deg);
                if (r.x < minX) minX = r.x;
                if (r.y < minY) minY = r.y;
                if (r.x > maxX) maxX = r.x;
                if (r.y > maxY) maxY = r.y;
            }
            const w = Math.max(1e-9, maxX - minX);
            const h = Math.max(1e-9, maxY - minY);
            const sx = (canvasW - 80) / w;
            const sy = (canvasH - 80) / h;
            const s = Math.min(sx, sy);
            const left = (canvasW - w * s) / 2;
            const top = (canvasH - h * s) / 2;
            const tx = left - minX * s;
            const ty = canvasH - top - maxY * s;
            return { s, tx, ty, bounds: { minX, minY, maxX, maxY } };
        }

        function buildSegments(polys) {
            const segs = [];
            polys.forEach((pl, idx) => {
                for (let i = 0; i < pl.points.length - 1; i++) {
                    segs.push({ a: pl.points[i], b: pl.points[i + 1], polyIndex: idx, segIndex: i });
                }
                if (pl.closed && pl.points.length > 1) {
                    segs.push({ a: pl.points[pl.points.length - 1], b: pl.points[0], polyIndex: idx, segIndex: pl.points.length - 1 });
                }
            });
            return segs;
        }

        function parseDXF(dxf) {
            const lines = dxf.split(/\r\n|[\r\n]/);
            const pairs = [];
            for (let i = 0; i < lines.length - 1; i += 2) {
                pairs.push({ code: lines[i].trim(), value: (lines[i + 1] ?? "").trim() });
            }

            const blocks = new Map();
            const worldPolys = [];
            const worldTexts = [];

            let i = 0;
            let curBlock = null;

            const pushLwpoly = (pts, closed) => {
                (curBlock ? curBlock.polys : worldPolys).push({ points: pts, closed });
            };
            const pushPolylineSeq = (seq, closed) => {
                (curBlock ? curBlock.polys : worldPolys).push({ points: seq, closed });
            };
            const pushLine = (a, b) => {
                (curBlock ? curBlock.polys : worldPolys).push({ points: [a, b], closed: false });
            };
            const pushText = (pt, text) => {
                if (curBlock) curBlock.texts.push({ pt, text });
                else worldTexts.push({ pt, text });
            };

            while (i < pairs.length) {
                const p = pairs[i];
                
                // BLOCK処理
                if (p.code === "0" && p.value === "BLOCK") {
                    let name = "";
                    let baseX = 0, baseY = 0;
                    for (let j = i + 1; j < pairs.length; j++) {
                        const c = pairs[j].code, v = pairs[j].value;
                        if (c === "2") name = v;
                        if (c === "10") baseX = parseFloat(v);
                        if (c === "20") baseY = parseFloat(v);
                        if (c === "0") { i = j - 1; break; }
                    }
                    curBlock = { name, base: { x: baseX, y: baseY }, polys: [], texts: [] };
                    
                    for (let j = i + 1; j < pairs.length; j++) {
                        const c0 = pairs[j].code, v0 = pairs[j].value;
                        if (c0 === "0" && v0 === "ENDBLK") {
                            blocks.set(curBlock.name, curBlock);
                            curBlock = null;
                            i = j;
                            break;
                        }
                        
                        if (c0 === "0" && v0 === "LWPOLYLINE") {
                            const pts = [];
                            let closed = false;
                            for (let k = j + 1; k < pairs.length; k++) {
                                const c = pairs[k].code, v = pairs[k].value;
                                if (c === "10") {
                                    const x = parseFloat(v);
                                    const y = parseFloat(pairs[k + 1]?.value ?? "0");
                                    k++;
                                    pts.push({ x, y });
                                }
                                if (c === "70") {
                                    const flag = parseInt(v, 10);
                                    closed = (flag & 1) === 1;
                                }
                                if (c === "0") { j = k - 1; break; }
                            }
                            pushLwpoly(pts, closed);
                        } else if (c0 === "0" && v0 === "POLYLINE") {
                            const pts = [];
                            let closed = false;
                            for (let k = j + 1; k < pairs.length; k++) {
                                const c = pairs[k].code, v = pairs[k].value;
                                if (c === "70") {
                                    const flag = parseInt(v, 10);
                                    closed = (flag & 1) === 1;
                                }
                                if (c === "0" && pairs[k].value === "VERTEX") {
                                    let vx = 0, vy = 0;
                                    for (let m = k + 1; m < pairs.length; m++) {
                                        const cc = pairs[m].code, vv = pairs[m].value;
                                        if (cc === "10") vx = parseFloat(vv);
                                        if (cc === "20") vy = parseFloat(vv);
                                        if (cc === "0") {
                                            k = m - 1;
                                            pts.push({ x: vx, y: vy });
                                            break;
                                        }
                                    }
                                }
                                if (c === "0" && v === "SEQEND") { j = k; break; }
                            }
                            pushPolylineSeq(pts, closed);
                        } else if (c0 === "0" && v0 === "LINE") {
                            let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
                            for (let k = j + 1; k < pairs.length; k++) {
                                const c = pairs[k].code, v = pairs[k].value;
                                if (c === "10") x1 = parseFloat(v);
                                if (c === "20") y1 = parseFloat(v);
                                if (c === "11") x2 = parseFloat(v);
                                if (c === "21") y2 = parseFloat(v);
                                if (c === "0") { j = k - 1; break; }
                            }
                            pushLine({ x: x1, y: y1 }, { x: x2, y: y2 });
                        } else if (c0 === "0" && (v0 === "TEXT" || v0 === "MTEXT")) {
                            let tx = 0, ty = 0;
                            let text = "";
                            for (let k = j + 1; k < pairs.length; k++) {
                                const c = pairs[k].code, v = pairs[k].value;
                                if (c === "10") tx = parseFloat(v);
                                if (c === "20") ty = parseFloat(v);
                                if (c === "1") text += v;
                                if (c === "0") { j = k - 1; break; }
                            }
                            if (text.trim()) pushText({ x: tx, y: ty }, text);
                        }
                    }
                    i++;
                    continue;
                }

                // ENTITIES直下のエンティティ処理
                if (p.code === "0" && p.value === "LWPOLYLINE") {
                    const pts = [];
                    let closed = false;
                    for (let j = i + 1; j < pairs.length; j++) {
                        const c = pairs[j].code, v = pairs[j].value;
                        if (c === "10") {
                            const x = parseFloat(v);
                            const y = parseFloat(pairs[j + 1]?.value ?? "0");
                            j++;
                            pts.push({ x, y });
                        }
                        if (c === "70") {
                            const flag = parseInt(v, 10);
                            closed = (flag & 1) === 1;
                        }
                        if (c === "0") { i = j - 1; break; }
                    }
                    pushLwpoly(pts, closed);
                    i++;
                    continue;
                }
                
                if (p.code === "0" && p.value === "POLYLINE") {
                    const pts = [];
                    let closed = false;
                    for (let j = i + 1; j < pairs.length; j++) {
                        const c = pairs[j].code, v = pairs[j].value;
                        if (c === "70") {
                            const flag = parseInt(v, 10);
                            closed = (flag & 1) === 1;
                        }
                        if (c === "0" && pairs[j].value === "VERTEX") {
                            let vx = 0, vy = 0;
                            for (let k = j + 1; k < pairs.length; k++) {
                                const cc = pairs[k].code, vv = pairs[k].value;
                                if (cc === "10") vx = parseFloat(vv);
                                if (cc === "20") vy = parseFloat(vv);
                                if (cc === "0") {
                                    j = k - 1;
                                    pts.push({ x: vx, y: vy });
                                    break;
                                }
                            }
                        }
                        if (c === "0" && v === "SEQEND") { i = j; break; }
                    }
                    pushPolylineSeq(pts, closed);
                    i++;
                    continue;
                }
                
                if (p.code === "0" && p.value === "LINE") {
                    let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
                    for (let j = i + 1; j < pairs.length; j++) {
                        const c = pairs[j].code, v = pairs[j].value;
                        if (c === "10") x1 = parseFloat(v);
                        if (c === "20") y1 = parseFloat(v);
                        if (c === "11") x2 = parseFloat(v);
                        if (c === "21") y2 = parseFloat(v);
                        if (c === "0") { i = j - 1; break; }
                    }
                    pushLine({ x: x1, y: y1 }, { x: x2, y: y2 });
                    i++;
                    continue;
                }
                
                if (p.code === "0" && (p.value === "TEXT" || p.value === "MTEXT")) {
                    let tx = 0, ty = 0;
                    let textVal = "";
                    for (let j = i + 1; j < pairs.length; j++) {
                        const c = pairs[j].code, v = pairs[j].value;
                        if (c === "10") tx = parseFloat(v);
                        if (c === "20") ty = parseFloat(v);
                        if (c === "1") textVal += v;
                        if (c === "0") { i = j - 1; break; }
                    }
                    if (textVal.trim()) pushText({ x: tx, y: ty }, textVal);
                    i++;
                    continue;
                }

                // INSERT（ブロック配置）
                if (p.code === "0" && p.value === "INSERT") {
                    let name = "";
                    let ix = 0, iy = 0;
                    let sx = 1, sy = 1;
                    let ang = 0;
                    for (let j = i + 1; j < pairs.length; j++) {
                        const c = pairs[j].code, v = pairs[j].value;
                        if (c === "2") name = v;
                        if (c === "10") ix = parseFloat(v);
                        if (c === "20") iy = parseFloat(v);
                        if (c === "41") sx = parseFloat(v) || 1;
                        if (c === "42") sy = parseFloat(v) || 1;
                        if (c === "50") ang = parseFloat(v) || 0;
                        if (c === "0") { i = j - 1; break; }
                    }
                    const def = blocks.get(name);
                    if (def) {
                        def.polys.forEach((pl) => {
                            const pts = pl.points.map((p) => transformPoint(p, def.base, { x: ix, y: iy }, sx, sy, ang));
                            worldPolys.push({ points: pts, closed: pl.closed, name });
                        });
                        def.texts.forEach((t) => {
                            worldTexts.push({ pt: transformPoint(t.pt, def.base, { x: ix, y: iy }, sx, sy, ang), text: `${name}:${t.text}` });
                        });
                    }
                    i++;
                    continue;
                }

                i++;
            }

            // bbox計算
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            worldPolys.forEach((pl) => {
                pl.points.forEach((p) => {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                });
            });
            const bbox = isFinite(minX) ? { min: { x: minX, y: minY }, max: { x: maxX, y: maxY } } : null;

            const blockNames = Array.from(new Set(worldPolys.map((p) => p.name).filter(Boolean)));
            return { polys: worldPolys, texts: worldTexts, bbox, blockNames };
        }

        function dist(a, b) {
            return Math.hypot(a.x - b.x, a.y - b.y);
        }
        
        function nearestOnSegment(p, a, b) {
            const vx = b.x - a.x, vy = b.y - a.y;
            const wx = p.x - a.x, wy = p.y - a.y;
            const len2 = vx * vx + vy * vy || 1e-9;
            let t = (vx * wx + vy * wy) / len2;
            t = Math.max(0, Math.min(1, t));
            return { x: a.x + t * vx, y: a.y + t * vy, t };
        }
        
        function cumulativeLengths(poly) {
            const P = poly.points;
            const cum = [0];
            let total = 0;
            for (let i = 0; i < P.length - 1; i++) {
                total += dist(P[i], P[i + 1]);
                cum.push(total);
            }
            if (poly.closed && P.length > 1) {
                total += dist(P[P.length - 1], P[0]);
                cum.push(total);
            }
            return { cum, total };
        }

        // メインコンポーネント
        function App() {
            const { text, pickFile } = useFileText();
            const [unitScale, setUnitScale] = useState(1);
            const [showLabels, setShowLabels] = useState(false);
            const [showGuides, setShowGuides] = useState(true);
            const [selectedBlock, setSelectedBlock] = useState("ALL");

            // ロック機能
            const [lockToPoly, setLockToPoly] = useState(true);
            const [lockedPoly, setLockedPoly] = useState(null);

            // 表示回転
            const [rot, setRot] = useState(0);
            const [autoFitOnRotate, setAutoFitOnRotate] = useState(true);
            const [pivot, setPivot] = useState({ x: 0, y: 0 });
            const [firstFitDone, setFirstFitDone] = useState(false);

            // 幅/丈の基準
            const [axisMode, setAxisMode] = useState("VIEW");

            // 計測ログ
            const [measureLog, setMeasureLog] = useState(() => {
                try {
                    const raw = localStorage.getItem("dxf-measure-log");
                    return raw ? JSON.parse(raw) : [];
                } catch {
                    return [];
                }
            });
            const [showLog, setShowLog] = useState(true);
            
            // ブロック名のカスタマイズ
            const [customBlockNames, setCustomBlockNames] = useState({});
            
            useEffect(() => {
                try {
                    localStorage.setItem("dxf-measure-log", JSON.stringify(measureLog));
                } catch {}
            }, [measureLog]);

            const parsed = useMemo(() => (text ? parseDXF(text) : null), [text]);
            const polysAll = parsed?.polys ?? [];
            const labelsAll = parsed?.texts ?? [];
            const bbox = parsed?.bbox ?? null;
            const blockNames = parsed?.blockNames ?? [];

            const visiblePolys = useMemo(() => {
                if (selectedBlock === "ALL") return polysAll;
                return polysAll.filter((p) => p.name === selectedBlock);
            }, [polysAll, selectedBlock]);

            const segments = useMemo(() => buildSegments(visiblePolys), [visiblePolys]);

            // キャンバス
            const canvasRef = useRef(null);
            const [view, setView] = useState({ scale: 1, tx: 0, ty: 0 });
            const dragging = useRef(null);

            // 選択点
            const [A, setA] = useState(null);
            const [B, setB] = useState(null);

            // DXF読み込み時にpivotを更新
            useEffect(() => {
                if (bbox) {
                    const cx = (bbox.min.x + bbox.max.x) / 2;
                    const cy = (bbox.min.y + bbox.max.y) / 2;
                    setPivot({ x: cx, y: cy });
                    setFirstFitDone(false);
                }
            }, [bbox]);

            // フィット処理
            const fitToCanvas = (deg, canvasW, canvasH, target = "ALL") => {
                const pts = [];
                if (target === "LOCKED" && lockedPoly != null && visiblePolys[lockedPoly]) {
                    pts.push(...visiblePolys[lockedPoly].points);
                } else {
                    visiblePolys.forEach(pl => {
                        pts.push(...pl.points);
                    });
                }
                if (pts.length === 0) return;
                const f = computeFitFromPoints(pts, pivot, deg, canvasW, canvasH);
                setView({ scale: f.s, tx: f.tx, ty: f.ty });
            };

            // 初回フィット & 回転時の自動フィット
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                if (!firstFitDone && bbox && polysAll.length > 0) {
                    fitToCanvas(rot, canvas.clientWidth, canvas.clientHeight, "ALL");
                    setFirstFitDone(true);
                    return;
                }
                if (autoFitOnRotate) {
                    fitToCanvas(rot, canvas.clientWidth, canvas.clientHeight, "ALL");
                }
            }, [rot, bbox, polysAll.length, selectedBlock]);

            useEffect(() => {
                setA(null);
                setB(null);
                setLockedPoly(null);
            }, [selectedBlock]);

            // 描画
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext("2d");
                const W = canvas.clientWidth, H = canvas.clientHeight;
                canvas.width = W;
                canvas.height = H;
                ctx.clearRect(0, 0, W, H);

                function wc(p) {
                    const r = rotateAround(p, pivot, rot);
                    return { x: r.x * view.scale + view.tx, y: H - (r.y * view.scale + view.ty) };
                }

                // 背景
                ctx.fillStyle = "#0b1220";
                ctx.fillRect(0, 0, W, H);

                // グリッド
                ctx.strokeStyle = "rgba(255,255,255,0.06)";
                ctx.lineWidth = 1;
                const grid = 100 * view.scale;
                if (grid > 8) {
                    ctx.beginPath();
                    for (let gx = view.tx % grid; gx < W; gx += grid) {
                        ctx.moveTo(gx, 0);
                        ctx.lineTo(gx, H);
                    }
                    for (let gy = view.ty % grid; gy < H; gy += grid) {
                        ctx.moveTo(0, gy);
                        ctx.lineTo(W, gy);
                    }
                    ctx.stroke();
                }

                // ポリライン描画
                const Colors = ["#0ea5e9", "#22c55e", "#f97316", "#a855f7", "#ef4444", "#14b8a6", "#eab308"];
                visiblePolys.forEach((pl, idx) => {
                    ctx.strokeStyle = Colors[idx % Colors.length];
                    ctx.lineWidth = lockedPoly === idx ? 4 : 2;
                    ctx.globalAlpha = lockedPoly === null || lockedPoly === idx ? 1 : 0.35;
                    ctx.beginPath();
                    pl.points.forEach((p, i) => {
                        const c = wc(p);
                        if (i === 0) ctx.moveTo(c.x, c.y);
                        else ctx.lineTo(c.x, c.y);
                    });
                    if (pl.closed && pl.points.length > 1) {
                        const c0 = wc(pl.points[0]);
                        ctx.lineTo(c0.x, c0.y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                });

                // ラベル
                if (showLabels) {
                    ctx.fillStyle = "rgba(255,255,255,0.75)";
                    ctx.font = "12px ui-sans-serif, system-ui";
                    labelsAll.forEach((lab) => {
                        const c = wc(lab.pt);
                        ctx.fillText(lab.text, c.x + 4, c.y - 4);
                    });
                }
            }, [polysAll, labelsAll, view, visiblePolys, showLabels, lockedPoly, rot, pivot]);

            // マウスイベント処理
            function canvasToWorld(e) {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const H = canvas.height;
                const rx = (x - view.tx) / view.scale;
                const ry = ((H - y) - view.ty) / view.scale;
                const r = rotateAround({ x: rx, y: ry }, pivot, -rot);
                return r;
            }

            const pushMeasureLog = (a, b) => {
                if (!a || !b) return;
                const APT = a.pt, BPT = b.pt;
                const straight = dist(APT, BPT) * unitScale;
                const raw = { x: BPT.x - APT.x, y: BPT.y - APT.y };
                const dv = axisMode === "VIEW" ? rotateVec(raw, rot) : raw;
                const width = Math.abs(dv.x) * unitScale;
                const length = Math.abs(dv.y) * unitScale;
                
                let along = null;
                if (a.poly === b.poly) {
                    const poly = visiblePolys[a.poly];
                    const { cum, total } = cumulativeLengths(poly);
                    const P = poly.points;
                    const segLen = (i) => dist(P[i], i === P.length - 1 ? (poly.closed ? P[0] : P[i + 1]) : P[i + 1]);
                    const posOn = (segIdx, t) => cum[segIdx] + segLen(segIdx) * t;
                    const sA = posOn(a.seg, a.t), sB = posOn(b.seg, b.t);
                    const d = Math.abs(sB - sA);
                    along = poly.closed ? Math.min(d, total - d) : d;
                    along *= unitScale;
                }
                
                // ブロック名を取得（カスタム名があればそれを、なければ元の名前を使用）
                const blockName = selectedBlock === "ALL" ? "全体" : (customBlockNames[selectedBlock] || selectedBlock);
                
                const entry = {
                    id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
                    time: Date.now(),
                    a: { ...APT },
                    b: { ...BPT },
                    width,
                    length,
                    straight,
                    along,
                    blockName  // ブロック名を追加
                };
                setMeasureLog((prev) => [entry, ...prev]);
            };

            const findNearest = (point) => {
                const pool = lockToPoly && lockedPoly !== null 
                    ? segments.filter(s => s.polyIndex === lockedPoly) 
                    : segments;
                let best = null;
                pool.forEach((s) => {
                    const q = nearestOnSegment(point, s.a, s.b);
                    const d = dist(point, q);
                    if (!best || d < best.d) {
                        best = { d, poly: s.polyIndex, seg: s.segIndex, t: q.t, spt: { x: q.x, y: q.y } };
                    }
                });
                return best;
            };

            const onClickCanvas = (e) => {
                if (!segments.length) return;
                const wpt = canvasToWorld(e);
                const best = findNearest(wpt);
                if (!best) return;

                if (!A) {
                    setA({ pt: best.spt, poly: best.poly, seg: best.seg, t: best.t });
                    if (lockToPoly) setLockedPoly(best.poly);
                } else if (!B) {
                    const newB = { pt: best.spt, poly: best.poly, seg: best.seg, t: best.t };
                    setB(newB);
                    pushMeasureLog(A, newB);
                } else {
                    setA({ pt: best.spt, poly: best.poly, seg: best.seg, t: best.t });
                    setB(null);
                    if (lockToPoly && lockedPoly === null) setLockedPoly(best.poly);
                }
            };

            const onWheel = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const H = canvas.height;
                const worldAtMouse = rotateAround({ x: (mx - view.tx) / view.scale, y: ((H - my) - view.ty) / view.scale }, pivot, -rot);
                const zoom = e.deltaY < 0 ? 1.1 : 0.9;
                const newScale = Math.max(0.05, Math.min(20, view.scale * zoom));
                const rx = rotateAround(worldAtMouse, pivot, rot);
                const newTx = mx - rx.x * newScale;
                const newTy = (H - my) - rx.y * newScale;
                setView({ scale: newScale, tx: newTx, ty: newTy });
                return false;
            };

            const onMouseDown = (e) => {
                dragging.current = { x: e.clientX, y: e.clientY };
            };
            
            const onMouseMove = (e) => {
                if (!dragging.current) return;
                const dx = e.clientX - dragging.current.x;
                const dy = e.clientY - dragging.current.y;
                dragging.current = { x: e.clientX, y: e.clientY };
                setView((v) => ({ ...v, tx: v.tx + dx, ty: v.ty - dy }));
            };
            
            const onMouseUp = () => {
                dragging.current = null;
            };

            // ガイド描画
            useEffect(() => {
                if (!A || !B || !canvasRef.current) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext("2d");
                const H = canvas.height;
                const wc = (p) => {
                    const r = rotateAround(p, pivot, rot);
                    return { x: r.x * view.scale + view.tx, y: H - (r.y * view.scale + view.ty) };
                };

                const drawTag = (text, c) => {
                    ctx.save();
                    ctx.font = "12px ui-sans-serif, system-ui";
                    const padX = 6;
                    const w = ctx.measureText(text).width + padX * 2;
                    const h = 18;
                    ctx.fillStyle = "rgba(2,6,23,0.85)";
                    ctx.strokeStyle = "rgba(148,163,184,0.6)";
                    ctx.lineWidth = 1;
                    ctx.fillRect(c.x + 8, c.y - h - 8, w, h);
                    ctx.strokeRect(c.x + 8, c.y - h - 8, w, h);
                    ctx.fillStyle = "#e2e8f0";
                    ctx.fillText(text, c.x + 8 + padX, c.y - 8 - 5);
                    ctx.restore();
                };

                const a = A.pt, b = B.pt;
                const ca = wc(a), cb = wc(b);

                // ② 直線
                ctx.save();
                ctx.strokeStyle = "#94a3b8";
                ctx.setLineDash([8, 6]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(ca.x, ca.y);
                ctx.lineTo(cb.x, cb.y);
                ctx.stroke();
                const mid = wc({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 });
                drawTag(`② 直線 ${(dist(a, b) * unitScale).toFixed(2)}`, mid);
                ctx.restore();

                if (showGuides) {
                    // ③ 幅/丈
                    if (axisMode === "VIEW") {
                        const ce = { x: cb.x, y: ca.y };
                        ctx.save();
                        ctx.strokeStyle = "#f59e0b";
                        ctx.setLineDash([4, 4]);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(ca.x, ca.y);
                        ctx.lineTo(ce.x, ce.y);
                        ctx.lineTo(cb.x, cb.y);
                        ctx.stroke();
                        const raw = { x: b.x - a.x, y: b.y - a.y };
                        const dv = rotateVec(raw, rot);
                        const width = Math.abs(dv.x) * unitScale;
                        const length = Math.abs(dv.y) * unitScale;
                        drawTag(`③ 幅/丈: ${width.toFixed(2)} / ${length.toFixed(2)}`, ce);
                        ctx.restore();
                    } else {
                        const elbow = { x: b.x, y: a.y };
                        const ce = wc(elbow);
                        ctx.save();
                        ctx.strokeStyle = "#f59e0b";
                        ctx.setLineDash([4, 4]);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(ca.x, ca.y);
                        ctx.lineTo(ce.x, ce.y);
                        ctx.lineTo(cb.x, cb.y);
                        ctx.stroke();
                        const width = Math.abs(b.x - a.x) * unitScale;
                        const length = Math.abs(b.y - a.y) * unitScale;
                        drawTag(`③ 幅/丈: ${width.toFixed(2)} / ${length.toFixed(2)}`, ce);
                        ctx.restore();
                    }

                    // ① 沿い距離
                    if (A.poly === B.poly) {
                        const poly = visiblePolys[A.poly];
                        const { cum, total } = cumulativeLengths(poly);
                        const P = poly.points;
                        const segLen = (i) => dist(P[i], i === P.length - 1 ? (poly.closed ? P[0] : P[i + 1]) : P[i + 1]);
                        const posOn = (segIdx, t) => cum[segIdx] + segLen(segIdx) * t;
                        const sA = posOn(A.seg, A.t), sB = posOn(B.seg, B.t);
                        
                        let s0 = Math.min(sA, sB), s1 = Math.max(sA, sB);
                        if (poly.closed) {
                            const dF = (sB - sA + total) % total;
                            if (dF <= total - dF) {
                                s0 = sA;
                                s1 = sA + dF;
                            } else {
                                s0 = sB;
                                s1 = sB + (total - dF);
                            }
                        }
                        const lenPath = s1 - s0;
                        
                        const pointAt = (s) => {
                            let ss = s;
                            if (poly.closed) {
                                ss = ((s % total) + total) % total;
                            } else {
                                ss = Math.max(0, Math.min(total, s));
                            }
                            let idx = 0;
                            while (idx < cum.length - 1 && ss > cum[idx + 1]) idx++;
                            const segL = (idx < P.length - 1) ? dist(P[idx], P[idx + 1]) : (poly.closed ? dist(P[idx], P[0]) : 1e-9);
                            const t = segL > 1e-9 ? (ss - cum[idx]) / segL : 0;
                            const aP = P[idx];
                            const bP = (idx < P.length - 1) ? P[idx + 1] : (poly.closed ? P[0] : P[idx]);
                            return { x: aP.x + (bP.x - aP.x) * t, y: aP.y + (bP.y - aP.y) * t };
                        };
                        
                        ctx.save();
                        ctx.strokeStyle = "#38bdf8";
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        const steps = Math.max(12, Math.min(200, Math.floor(lenPath / Math.max(1, total / 80))));
                        for (let i = 0; i <= steps; i++) {
                            const s = s0 + (lenPath * i) / steps;
                            const pw = pointAt(s);
                            const c = wc(pw);
                            if (i === 0) ctx.moveTo(c.x, c.y);
                            else ctx.lineTo(c.x, c.y);
                        }
                        ctx.stroke();
                        const midS = s0 + lenPath / 2;
                        const pm = wc(pointAt(midS));
                        drawTag(`① 沿い ${(lenPath * unitScale).toFixed(2)}`, pm);
                        ctx.restore();
                    }
                }

                // A/Bマーカー
                ctx.save();
                ctx.fillStyle = "#22c55e";
                ctx.beginPath();
                ctx.arc(ca.x, ca.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#ef4444";
                ctx.beginPath();
                ctx.arc(cb.x, cb.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }, [A, B, view, visiblePolys, unitScale, showGuides, rot, pivot, axisMode]);

            // 計測結果
            const result = useMemo(() => {
                if (!A || !B) return null;
                const a = A.pt, b = B.pt;
                const straight = dist(a, b) * unitScale;
                const raw = { x: b.x - a.x, y: b.y - a.y };
                const dv = axisMode === "VIEW" ? rotateVec(raw, rot) : raw;
                const dx = dv.x * unitScale;
                const dy = dv.y * unitScale;
                
                if (A.poly === B.poly) {
                    const poly = visiblePolys[A.poly];
                    const { cum, total } = cumulativeLengths(poly);
                    const P = poly.points;
                    const segLen = (i) => dist(P[i], i === P.length - 1 ? (poly.closed ? P[0] : P[i + 1]) : P[i + 1]);
                    const posOn = (segIdx, t) => cum[segIdx] + segLen(segIdx) * t;
                    const aLen = posOn(A.seg, A.t);
                    const bLen = posOn(B.seg, B.t);
                    const d = Math.abs(bLen - aLen);
                    const minor = poly.closed ? Math.min(d, total - d) : d;
                    const major = poly.closed ? Math.max(d, total - d) : NaN;
                    return { straight, dx, dy, along: { samePoly: true, minor: minor * unitScale, major: major * unitScale, perimeter: total * unitScale } };
                }
                return { straight, dx, dy, along: { samePoly: false, minor: NaN, major: NaN, perimeter: NaN } };
            }, [A, B, visiblePolys, unitScale, axisMode, rot]);

            const fmt = (n) => (n == null || isNaN(n) ? "-" : n.toFixed(2));

            // キャンバスのホイールイベントを確実に捕捉
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const handleWheel = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // ズーム処理をここで実行
                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    const H = canvas.height;
                    const worldAtMouse = rotateAround({ x: (mx - view.tx) / view.scale, y: ((H - my) - view.ty) / view.scale }, pivot, -rot);
                    const zoom = e.deltaY < 0 ? 1.1 : 0.9;
                    const newScale = Math.max(0.05, Math.min(20, view.scale * zoom));
                    const rx = rotateAround(worldAtMouse, pivot, rot);
                    const newTx = mx - rx.x * newScale;
                    const newTy = (H - my) - rx.y * newScale;
                    setView({ scale: newScale, tx: newTx, ty: newTy });
                    
                    return false;
                };
                
                // passiveをfalseにして、preventDefaultが確実に効くようにする
                canvas.addEventListener('wheel', handleWheel, { passive: false });
                
                return () => {
                    canvas.removeEventListener('wheel', handleWheel);
                };
            }, [view, pivot, rot]);  // 依存配列に必要な値を追加

            return React.createElement('div', {
                className: "h-screen grid grid-cols-[520px_1fr] bg-slate-950 text-slate-200"
            }, [
                React.createElement('aside', {
                    key: 'sidebar',
                    className: "p-4 border-r border-slate-700 space-y-3 overflow-y-auto sidebar-scroll"
                }, [
                    React.createElement('h1', { key: 'title', className: "text-lg font-semibold" }, 'DXF 計測ツール（スタンドアロン版）'),
                    
                    React.createElement('div', { key: 'file-input' }, 
                        React.createElement('input', {
                            type: 'file',
                            accept: '.dxf',
                            onChange: (e) => {
                                const f = e.target.files?.[0];
                                if (f) {
                                    pickFile(f);
                                    setA(null);
                                    setB(null);
                                    setSelectedBlock("ALL");
                                    setLockedPoly(null);
                                    setFirstFitDone(false);
                                }
                            }
                        })
                    ),
                    
                    React.createElement('div', { key: 'controls', className: "grid gap-2" }, [
                        React.createElement('label', { key: 'scale', className: "text-sm" }, [
                            '単位スケール（DXF → 出力）',
                            React.createElement('input', {
                                type: 'number',
                                step: 0.01,
                                value: unitScale,
                                onChange: (e) => setUnitScale(parseFloat(e.target.value) || 1),
                                className: "mt-1 w-full bg-slate-900 text-white border border-slate-700 rounded px-2 py-1"
                            }),
                            React.createElement('div', { className: "text-xs text-slate-400" }, 
                                '例：DXF=mm→mm=1、cm→mm=10、inch→mm=25.4'
                            )
                        ]),
                        
                        blockNames.length > 0 && React.createElement('div', { key: 'block-select-container', className: "space-y-2" }, [
                            React.createElement('label', { key: 'block-select', className: "text-sm block" }, [
                                '表示ブロック',
                                React.createElement('select', {
                                    value: selectedBlock,
                                    onChange: (e) => setSelectedBlock(e.target.value),
                                    className: "mt-1 w-full bg-slate-900 text-white border border-slate-700 rounded px-2 py-1"
                                }, [
                                    React.createElement('option', { key: 'all', value: 'ALL' }, '（全て表示）'),
                                    ...blockNames.map((bn) => 
                                        React.createElement('option', { key: bn, value: bn }, 
                                            customBlockNames[bn] ? `${bn} - ${customBlockNames[bn]}` : bn
                                        )
                                    )
                                ])
                            ]),
                            selectedBlock !== 'ALL' && React.createElement('div', { key: 'custom-name', className: "flex gap-2" }, [
                                React.createElement('input', {
                                    type: 'text',
                                    placeholder: `${selectedBlock}の表示名を入力（例：後見頃）`,
                                    value: customBlockNames[selectedBlock] || '',
                                    onChange: (e) => {
                                        const newNames = { ...customBlockNames };
                                        if (e.target.value) {
                                            newNames[selectedBlock] = e.target.value;
                                        } else {
                                            delete newNames[selectedBlock];
                                        }
                                        setCustomBlockNames(newNames);
                                    },
                                    className: "flex-1 bg-slate-900 text-white border border-slate-700 rounded px-2 py-1 text-sm"
                                })
                            ])
                        ]),
                        
                        // ロック設定
                        React.createElement('div', { key: 'lock-settings', className: "mt-1 p-2 bg-slate-900 border border-slate-700 rounded space-y-2" }, [
                            React.createElement('label', { className: "inline-flex items-center gap-2 text-sm" }, [
                                React.createElement('input', {
                                    type: 'checkbox',
                                    checked: lockToPoly,
                                    onChange: (e) => {
                                        setLockToPoly(e.target.checked);
                                        if (!e.target.checked) setLockedPoly(null);
                                    }
                                }),
                                '同一ポリラインにロック（推奨）'
                            ]),
                            React.createElement('div', { className: "text-xs text-slate-400" },
                                lockToPoly ? (
                                    lockedPoly === null 
                                        ? "最初のクリックで対象ポリラインを自動ロックします。"
                                        : `対象ポリラインをロック中（#${lockedPoly}${visiblePolys[lockedPoly]?.name ? `: ${visiblePolys[lockedPoly].name}` : ""}）`
                                ) : "ロックしない：任意の線にスナップします。"
                            ),
                            React.createElement('div', { className: "flex gap-2 flex-wrap" }, [
                                React.createElement('button', {
                                    key: 'unlock',
                                    onClick: () => setLockedPoly(null),
                                    className: "px-2 py-1 text-xs bg-slate-800 border border-slate-700 rounded"
                                }, 'ロック解除'),
                                React.createElement('button', {
                                    key: 'reset',
                                    onClick: () => { setA(null); setB(null); },
                                    className: "px-2 py-1 text-xs bg-slate-800 border border-slate-700 rounded"
                                }, 'A/Bリセット')
                            ])
                        ]),
                        
                        // 回転 & フィット
                        React.createElement('div', { key: 'rotation', className: "mt-1 p-2 bg-slate-900 border border-slate-700 rounded space-y-2" }, [
                            React.createElement('div', { className: "flex items-center justify-between" }, [
                                React.createElement('span', { className: "text-sm" }, [
                                    '表示回転: ',
                                    React.createElement('strong', {}, `${rot}°`)
                                ]),
                                React.createElement('div', { className: "flex gap-2" }, [
                                    React.createElement('button', {
                                        onClick: () => setRot((p) => ((((p - 90) + 360) % 360))),
                                        className: "px-2 py-1 text-xs bg-slate-800 border border-slate-700 rounded"
                                    }, '↺ -90°'),
                                    React.createElement('button', {
                                        onClick: () => setRot((p) => ((((p + 90) % 360)))),
                                        className: "px-2 py-1 text-xs bg-slate-800 border border-slate-700 rounded"
                                    }, '↻ +90°'),
                                    React.createElement('button', {
                                        onClick: () => setRot(0),
                                        className: "px-2 py-1 text-xs bg-slate-800 border border-slate-700 rounded"
                                    }, '0°')
                                ])
                            ]),
                            React.createElement('div', { className: "flex items-center justify-between gap-2 flex-wrap" }, [
                                React.createElement('label', { className: "inline-flex items-center gap-2 text-sm" }, [
                                    React.createElement('input', {
                                        type: 'checkbox',
                                        checked: autoFitOnRotate,
                                        onChange: (e) => setAutoFitOnRotate(e.target.checked)
                                    }),
                                    '回転時に自動フィット'
                                ]),
                                React.createElement('div', { className: "flex gap-2" }, [
                                    React.createElement('button', {
                                        onClick: () => {
                                            const c = canvasRef.current;
                                            if (c) fitToCanvas(rot, c.clientWidth, c.clientHeight, "ALL");
                                        },
                                        className: "px-2 py-1 text-xs bg-slate-800 border border-slate-700 rounded"
                                    }, '全体にフィット'),
                                    React.createElement('button', {
                                        onClick: () => {
                                            const c = canvasRef.current;
                                            if (c) fitToCanvas(rot, c.clientWidth, c.clientHeight, "LOCKED");
                                        },
                                        disabled: lockedPoly == null,
                                        className: "px-2 py-1 text-xs bg-slate-800 border border-slate-700 rounded disabled:opacity-50"
                                    }, 'ロックにフィット')
                                ])
                            ])
                        ]),
                        
                        // 幅/丈の基準
                        React.createElement('div', { key: 'axis-mode', className: "mt-1 p-2 bg-slate-900 border border-slate-700 rounded space-y-2" }, [
                            React.createElement('div', { className: "text-sm font-medium" }, '幅/丈の基準'),
                            React.createElement('label', { className: "text-sm inline-flex items-center gap-2" }, [
                                React.createElement('input', {
                                    type: 'radio',
                                    name: 'axismode',
                                    checked: axisMode === "VIEW",
                                    onChange: () => setAxisMode("VIEW")
                                }),
                                '画面基準（回転後）'
                            ]),
                            React.createElement('label', { className: "text-sm inline-flex items-center gap-2" }, [
                                React.createElement('input', {
                                    type: 'radio',
                                    name: 'axismode',
                                    checked: axisMode === "DXF",
                                    onChange: () => setAxisMode("DXF")
                                }),
                                'DXF座標基準'
                            ]),
                            React.createElement('div', { className: "text-xs text-slate-400" }, 
                                '※ 画面基準＝いま見えている上下左右。DXF座標基準＝元データのX/Y。'
                            )
                        ])
                    ]),
                    
                    // 測定結果表示
                    React.createElement('div', { key: 'measurements', className: "text-sm leading-6" }, [
                        React.createElement('div', { className: "mb-1" }, [
                            React.createElement('strong', {}, 'A: '),
                            A ? `(${A.pt.x.toFixed(2)}, ${A.pt.y.toFixed(2)})` 
                              : React.createElement('span', { className: "text-slate-400" }, '未選択')
                        ]),
                        React.createElement('div', { className: "mb-2" }, [
                            React.createElement('strong', {}, 'B: '),
                            B ? `(${B.pt.x.toFixed(2)}, ${B.pt.y.toFixed(2)})` 
                              : React.createElement('span', { className: "text-slate-400" }, '未選択')
                        ]),
                        A && B && result && React.createElement('div', { className: "mt-2 p-3 bg-slate-900 border border-slate-700 rounded" }, [
                            React.createElement('div', { className: "mb-1" }, [
                                React.createElement('strong', {}, '② 直線距離: '),
                                result.straight.toFixed(2)
                            ]),
                            React.createElement('div', { className: "mb-1" }, [
                                React.createElement('strong', {}, '③ 幅 / 丈: '),
                                `${Math.abs(result.dx).toFixed(2)} / ${Math.abs(result.dy).toFixed(2)} `,
                                React.createElement('span', { className: "text-slate-400" }, 
                                    `(符号 dx=${result.dx.toFixed(2)} / dy=${result.dy.toFixed(2)})`
                                )
                            ]),
                            result.along?.samePoly ? [
                                React.createElement('div', { key: 'along', className: "mb-1" }, [
                                    React.createElement('strong', {}, 
                                        `① 沿い距離（短経路${visiblePolys[A.poly]?.closed ? "/長経路" : ""}）: `
                                    ),
                                    result.along.minor.toFixed(2),
                                    visiblePolys[A.poly]?.closed ? ` / ${result.along.major.toFixed(2)}` : ""
                                ]),
                                React.createElement('div', { key: 'perimeter' }, [
                                    React.createElement('strong', {}, '選択ポリラインの外周: '),
                                    result.along.perimeter.toFixed(2)
                                ])
                            ] : React.createElement('div', { className: "text-amber-400" }, 
                                'AとBが同一ポリライン上ではありません（沿い距離は計算不可）。'
                            )
                        ])
                    ]),
                    
                    // 計測ログ
                    React.createElement('div', { key: 'log', className: "mt-3 p-3 bg-slate-900 border border-slate-700 rounded" }, [
                        React.createElement('div', { className: "flex items-center justify-between mb-2" }, [
                            React.createElement('strong', {}, '計測ログ'),
                            React.createElement('div', { className: "flex items-center gap-3" }, [
                                React.createElement('label', { className: "text-sm inline-flex items-center gap-1" }, [
                                    React.createElement('input', {
                                        type: 'checkbox',
                                        checked: showLog,
                                        onChange: (e) => setShowLog(e.target.checked)
                                    }),
                                    '表示'
                                ]),
                                React.createElement('button', {
                                    onClick: () => setMeasureLog([]),
                                    className: "text-xs px-2 py-1 bg-slate-800 border border-slate-700 rounded"
                                }, '全消去')
                            ])
                        ]),
                        showLog && (
                            measureLog.length === 0 
                                ? React.createElement('div', { className: "text-slate-400 text-sm" }, '（まだ計測がありません）')
                                : React.createElement('ol', { className: "space-y-2 max-h-64 overflow-y-auto pr-1" },
                                    measureLog.map((m, idx) => 
                                        React.createElement('li', {
                                            key: m.id,
                                            className: "text-sm bg-slate-950/40 border border-slate-700 rounded p-2"
                                        }, [
                                            React.createElement('div', { className: "text-xs text-slate-400 mb-1" },
                                                `#${measureLog.length - idx} ・${new Date(m.time).toLocaleTimeString()}・${m.blockName ? `【${m.blockName}】・` : ''}A(${m.a.x.toFixed(2)},${m.a.y.toFixed(2)})→B(${m.b.x.toFixed(2)},${m.b.y.toFixed(2)})`
                                            ),
                                            React.createElement('div', {}, [
                                                '幅: ',
                                                React.createElement('span', { className: "font-medium" }, fmt(m.width)),
                                                ' / 丈: ',
                                                React.createElement('span', { className: "font-medium" }, fmt(m.length))
                                            ]),
                                            React.createElement('div', {}, [
                                                '直線距離: ',
                                                React.createElement('span', { className: "font-medium" }, fmt(m.straight))
                                            ]),
                                            React.createElement('div', {}, [
                                                '沿い距離: ',
                                                React.createElement('span', { className: "font-medium" }, 
                                                    m.along == null ? '—' : fmt(m.along)
                                                )
                                            ])
                                        ])
                                    )
                                )
                        )
                    ]),
                    
                    React.createElement('div', { key: 'help', className: "text-xs text-slate-400 mt-2 space-y-1" }, [
                        React.createElement('div', {}, [
                            '凡例: ',
                            React.createElement('span', { className: "text-slate-300" }, '②灰色点線=直線距離'),
                            ' / ',
                            React.createElement('span', { className: "text-slate-300" }, '③橙L字=幅/丈'),
                            ' / ',
                            React.createElement('span', { className: "text-slate-300" }, '①青太線=沿い距離(短経路)')
                        ]),
                        React.createElement('div', {}, '操作: 左クリック=スナップ / ホイール=ズーム / ドラッグ=パン'),
                        React.createElement('div', {}, [
                            'ヒント: 「同一ポリラインにロック」をONにすると、最初にクリックした線が',
                            React.createElement('strong', {}, 'ハイライト'),
                            'され、以降A/Bは必ずその線上にスナップします。重なり線の測定に有効。'
                        ])
                    ])
                ]),
                
                React.createElement('main', { key: 'canvas-container', className: "relative" },
                    React.createElement('canvas', {
                        ref: canvasRef,
                        className: "w-full h-full block cursor-crosshair",
                        onClick: onClickCanvas,
                        onWheel: onWheel,
                        onMouseDown: onMouseDown,
                        onMouseMove: onMouseMove,
                        onMouseUp: onMouseUp,
                        onMouseLeave: onMouseUp
                    })
                )
            ]);
        }

        // レンダリング
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>